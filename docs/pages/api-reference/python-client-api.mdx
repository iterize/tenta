# Tenta Python Client API Reference

```python
class TentaClient()
```


#### \_\_init\_\_

```python
def __init__(mqtt_host: str,
             mqtt_port: int,
             mqtt_identifier: str,
             mqtt_password: str,
             sensor_identifier: str,
             config_revision: Optional[int] = None,
             on_config_message: Optional[Callable[[ConfigMessage],
                                                  None]] = None,
             on_publish: Optional[Callable[[int], None]] = None,
             connection_timeout: int = 8,
             tls_context: Optional[ssl.SSLContext] = None,
             tls_parameters: Optional[TLSParameters] = None,
             tls_insecure: Optional[bool] = None) -> None
```

Create a new Tenta client. Prevents creating multiple instances.

You can look at the [advanced example](/user-guide/python-client-example#advanced-example)
in the documentation to see how to pass the TLS parameters.

**Arguments**:

- `mqtt_host` - The host of the MQTT broker.
- `mqtt_port` - The port of the MQTT broker.
- `mqtt_identifier` - The MQTT identifier.
- `mqtt_password` - The MQTT password.
- `sensor_identifier` - The sensor identifier.
- `config_revision` - The current revision of the sensor.
- `on_config_message` - A callback that is called when a new configuration message is received.
- `on_publish` - A callback that is called when a message is published.
- `connection_timeout` - How many seconds to wait for the initial connection to the MQTT
  broker until a `TimeoutError` is raised.
- `tls_context` - The TLS context to use for the connection. This will be passed as
  is to `paho.mqtt.client.Client.tls_set_context`.
- `tls_parameters` - The TLS parameters to use for the connection. This will be passed
  as is to `paho.mqtt.client.Client.tls_set`.
- `tls_insecure` - Whether to disable TLS verification. This will be passed as is to
  `paho.mqtt.client.Client.tls_insecure_set`.
  

**Raises**:

- `RuntimeError` - If there is already a Tenta client instance.
- `ConnectionError` - If the client could not connect to the MQTT broker.


#### publish\_log

```python
def publish_log(severity: Literal["info", "warning", "error"],
                message: str,
                timestamp: Optional[float] = None,
                wait_for_publish: bool = False,
                wait_for_publish_timeout: int = 60) -> int
```

Publish a log to the MQTT broker.

**Arguments**:

- `severity` - The severity of the log.
- `message` - The log message.
- `timestamp` - Timestamp of the log. Uses the current time if not specified.
- `wait_for_publish` - Whether to wait for the message to be published.
- `wait_for_publish_timeout` - How many seconds to wait for the message to be published
  until a `TimeoutError` is raised. Only used if
  `wait_for_publish` is `True`.
  

**Returns**:

  The `message_id` of the published message.


#### publish\_measurement

```python
def publish_measurement(value: Dict[str, Union[float, int]],
                        timestamp: Optional[float] = None,
                        wait_for_publish: bool = False,
                        wait_for_publish_timeout: int = 60) -> int
```

Publish a measurement to the MQTT broker.

**Arguments**:

- `value` - The measurement value, e.g. `{"temperature": 20.5, "humidity": 50}`.
- `timestamp` - Timestamp of the log. Uses the current time if not specified.
- `wait_for_publish` - Whether to wait for the message to be published.
- `wait_for_publish_timeout` - How many seconds to wait for the message to be published
  until a `TimeoutError` is raised. Only used if
  `wait_for_publish` is `True`.
  
- `Returns` - The `message_id` of the published message.


#### publish\_acknowledgement

```python
def publish_acknowledgement(success: bool,
                            revision: Optional[int],
                            timestamp: Optional[float] = None,
                            wait_for_publish: bool = False,
                            wait_for_publish_timeout: int = 60) -> int
```

Publish an acknowledgement to the MQTT broker.

**Arguments**:

- `success` - Whether the configuration was processed/applied successfully.
- `revision` - The revision of the configuration that was processed/applied.
- `timestamp` - Timestamp of the log. Uses the current time if not specified.
- `wait_for_publish` - Whether to wait for the message to be published.
- `wait_for_publish_timeout` - How many seconds to wait for the message to be published
  until a `TimeoutError` is raised. Only used if
  `wait_for_publish` is `True`.
  
- `Returns` - The `message_id` of the published message.


#### was\_message\_published

```python
def was_message_published(message_id: int) -> bool
```

Check if a message with a given id was published.

**Arguments**:

- `message_id` - The `message_id` of the message.
  
- `Returns` - Whether the message was published.


#### get\_active\_message\_count

```python
def get_active_message_count() -> int
```

Get how many messages have not yet been published.

Returns: The number of messages that have not yet been published.


#### wait\_for\_publish

```python
def wait_for_publish(timeout: Optional[int] = 60) -> None
```

Wait until all messages have been published.

**Arguments**:

- `timeout` - How many seconds to wait until a `TimeoutError` is raised.


#### get\_latest\_received\_config\_message

```python
def get_latest_received_config_message() -> Optional[ConfigMessage]
```

Return the latest received configuration.

Returns: The latest received configuration or `None` if no configuration has been received
yet.


#### teardown

```python
def teardown() -> None
```

Disconnect from the MQTT broker and stop the client loop.

